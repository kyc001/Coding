我们在ast.h中定义了term的语法树，也是本次大作业要处理的结构
struct term {
    term_type type;
    union {
        char* var;
        constant constnum;
        oper_type  op;
        struct {
            term *left;
            term *right;
        } apply_term;
        struct {
            binder_type type;
            char* binder_var;
            term *body;
        } binder_term;
        pred_type pred_op;
        connect_type connect_op;
        struct {
            quant_type type;
            char* quant_var;
            term *body;
        } Quant_term;
        struct {
            quant_type type;
            term *quant_term;
            term *body;
        } RawQuant_term;
    } content;
    int lineNum;
};

对于term的解释如下：
1.一个变量名是一个term，对应union中的char* var

2.一个常数是一个term，包括整数和正负无穷，对应union中的constant constnum

3.一个运算符是一个term，包括comma(逗号)，Plus(加号)，Deri(求导)，Cos(余弦)，Lim(取极限)等等等，具体可以查看枚举类型enum oper_type
对应union中的oper_type  op

4.将一个term apply到另一个term上也构成一个term，比如f(x)就可以写为(apply (Var"f") (Var"x"));
1+2可以写为 （apply (apply Plus (num:1) (num:2))
对应union中
struct {
    term *left;
    term *right;
} apply_term;

5.lambda表达式是一个term，比如我们如果有函数定义f(x):= x+1,那么可以写为
var"f" = lambda "x" (Apply (apply plus (var "x") (num:1)))
对应union中
struct {
    binder_type type;
    char* binder_var;
    term *body;
} binder_term;

6.谓词符号是term，包括等于、小于、大于、属于、连续、有界等等,具体可以查看枚举类型pred_type
比如 a=b 可以写为 apply (apply eq (var"a") (var"b"))
5中的例子也就进一步写为 apply (apply eq (var"f")) (lambda "x" (Apply (apply plus (var "x") (num:1))))
对应union中pred_type pred_op

7.逻辑连接词也是term，包括and，or，imply，iff，not
比如t1->t2就写为 apply (apply imply t1) t2
对应union中connect_type connect_op

8.若t是一个term，x是变量符号，则（forall/exists x， t）也是一个term，写为（Forall “x" t）
对应union中
struct {
    quant_type type;
    char* quant_var;
    term *body;
} Quant_term;

9.若t1，t2都是term，则（forall/exists t1， t2）也是一个term
比如forall x>0, x>1 可以写为(RawQuant Forall (apply (apply gt (var"x")) (num:0)) (apply (apply gt (var"x")) (num:1)))

更多例子可以查看example文件夹下.md文件中“要证”后面的命题和.v文件中“Definition stmt: term :=”后面的内容