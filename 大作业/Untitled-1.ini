#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "term.h" // 假设term的定义在这里

// 定义多项式的新结构
typedef struct TermNode {
    char* term;     // 项的字符串表示，如"a^2"或"sinx"
    int coefficient; // 系数
    struct TermNode* next;
} TermNode;

typedef struct Polynomial {
    TermNode* head;
} Polynomial;

// 创建新的多项式
Polynomial* createPolynomial() {
    Polynomial* poly = (Polynomial*)malloc(sizeof(Polynomial));
    poly->head = NULL;
    return poly;
}

// 创建新的项节点
TermNode* createTermNode(char* term, int coefficient) {
    TermNode* node = (TermNode*)malloc(sizeof(TermNode));
    node->term = strdup(term);
    node->coefficient = coefficient;
    node->next = NULL;
    return node;
}

// 比较两个项是否相同（不考虑系数）
int compareTerms(char* term1, char* term2) {
    return strcmp(term1, term2) == 0;
}

// 添加项到多项式
void addTerm(Polynomial* poly, char* term, int coefficient) {
    if (coefficient == 0) return; // 系数为0则不添加
    
    TermNode* current = poly->head;
    TermNode* prev = NULL;
    
    // 查找是否已有相同的项
    while (current != NULL) {
        if (compareTerms(current->term, term)) {
            current->coefficient += coefficient;
            // 如果合并后系数为0，移除该项
            if (current->coefficient == 0) {
                if (prev == NULL) {
                    poly->head = current->next;
                } else {
                    prev->next = current->next;
                }
                free(current->term);
                free(current);
            }
            free(term); // 不再需要传入的term副本
            return;
        }
        prev = current;
        current = current->next;
    }
    
    // 没有找到相同项，添加新节点
    TermNode* newNode = createTermNode(term, coefficient);
    if (prev == NULL) {
        poly->head = newNode;
    } else {
        prev->next = newNode;
    }
}

// 从term构建多项式
Polynomial* buildPolynomial(term* t) {
    // 这里需要实现从语法树构建多项式的逻辑
    // 这是一个复杂的递归过程，需要处理各种运算符和函数
    // 简化版示例，实际实现需要根据term的具体结构进行调整
    Polynomial* poly = createPolynomial();
    
    // 示例：假设t是一个简单的加法表达式
    if (t->type == ADD) {
        Polynomial* left = buildPolynomial(t->left);
        Polynomial* right = buildPolynomial(t->right);
        
        // 合并两个多项式
        TermNode* current = left->head;
        while (current != NULL) {
            addTerm(poly, strdup(current->term), current->coefficient);
            current = current->next;
        }
        
        current = right->head;
        while (current != NULL) {
            addTerm(poly, strdup(current->term), current->coefficient);
            current = current->next;
        }
        
        // 释放临时多项式
        // 注意：这里需要更完善的内存管理
    } else if (t->type == NUMBER) {
        // 处理常数项
        char* term = strdup("1"); // 常数项的特殊表示
        addTerm(poly, term, t->value);
    } else if (t->type == VARIABLE) {
        // 处理变量
        char* term = malloc(strlen(t->varname) + 1);
        strcpy(term, t->varname);
        addTerm(poly, term, 1);
    }
    // 其他情况需要类似处理
    
    return poly;
}

// 比较两个多项式是否相等
int comparePolynomials(Polynomial* poly1, Polynomial* poly2) {
    TermNode* current1 = poly1->head;
    
    // 检查poly1中的每个项是否在poly2中存在且系数相同
    while (current1 != NULL) {
        int found = 0;
        TermNode* current2 = poly2->head;
        
        while (current2 != NULL) {
            if (compareTerms(current1->term, current2->term)) {
                if (current1->coefficient != current2->coefficient) {
                    return 0; // 项相同但系数不同
                }
                found = 1;
                break;
            }
            current2 = current2->next;
        }
        
        if (!found) {
            return 0; // poly1中有项不在poly2中
        }
        
        current1 = current1->next;
    }
    
    // 检查poly2中的每个项是否在poly1中存在（确保没有额外项）
    TermNode* current2 = poly2->head;
    while (current2 != NULL) {
        int found = 0;
        TermNode* current1 = poly1->head;
        
        while (current1 != NULL) {
            if (compareTerms(current2->term, current1->term)) {
                found = 1;
                break;
            }
            current1 = current1->next;
        }
        
        if (!found) {
            return 0; // poly2中有项不在poly1中
        }
        
        current2 = current2->next;
    }
    
    return 1; // 所有项都匹配
}

// 释放多项式内存
void freePolynomial(Polynomial* poly) {
    TermNode* current = poly->head;
    while (current != NULL) {
        TermNode* temp = current;
        current = current->next;
        free(temp->term);
        free(temp);
    }
    free(poly);
}

// 多项式solver
int solver_poly(term* t) {
    // 检查是否是等式
    if (t == NULL || t->type != EQUAL) {
        return -1; // 不是等式，无法判断
    }
    
    // 构建左右两边的多项式
    Polynomial* left = buildPolynomial(t->left);
    Polynomial* right = buildPolynomial(t->right);
    
    // 比较两个多项式
    int result = comparePolynomials(left, right);
    
    // 释放内存
    freePolynomial(left);
    freePolynomial(right);
    
    return result;
}

// 有理式solver
int solver_rational(term* t) {
    // 检查是否是等式
    if (t == NULL || t->type != EQUAL) {
        return -1; // 不是等式，无法判断
    }
    
    // 假设等式两边都是有理式（即除法表达式）
    term* left = t->left;
    term* right = t->right;
    
    if (left->type != DIV || right->type != DIV) {
        return -1; // 不是有理式，无法判断
    }
    
    // 提取分子和分母
    term* p1 = left->left;   // 左分子
    term* p2 = left->right;  // 左分母
    term* p3 = right->left;  // 右分子
    term* p4 = right->right; // 右分母
    
    // 构建四个多项式
    Polynomial* poly_p1 = buildPolynomial(p1);
    Polynomial* poly_p2 = buildPolynomial(p2);
    Polynomial* poly_p3 = buildPolynomial(p3);
    Polynomial* poly_p4 = buildPolynomial(p4);
    
    // 计算 p1*p4 和 p3*p2
    // 这里需要实现多项式乘法
    // 简化版：假设两个多项式相乘的结果
    Polynomial* product1 = multiplyPolynomials(poly_p1, poly_p4);
    Polynomial* product2 = multiplyPolynomials(poly_p3, poly_p2);
    
    // 比较两个乘积多项式
    int result = comparePolynomials(product1, product2);
    
    // 释放内存
    freePolynomial(poly_p1);
    freePolynomial(poly_p2);
    freePolynomial(poly_p3);
    freePolynomial(poly_p4);
    freePolynomial(product1);
    freePolynomial(product2);
    
    return result;
}

// 多项式乘法函数（简化版）
Polynomial* multiplyPolynomials(Polynomial* poly1, Polynomial* poly2) {
    // 实际实现需要考虑项的乘法和合并同类项
    // 这里仅为示例
    return createPolynomial();
}    